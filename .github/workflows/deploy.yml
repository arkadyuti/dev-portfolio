name: Deploy Portfolio
on:
  push:
    branches: [ main ]  # Change this to match your main branch name if different
  workflow_dispatch:    # Allows manual workflow runs

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up SSH
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          known_hosts: 'just-a-placeholder'

      - name: Add remote host to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

      - name: Verify SSH connection
        run: |
          echo "Testing SSH connection..."
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} "echo 'SSH connection successful' && mkdir -p ~/services/portfolio ~/services/docker-images"

      - name: Create .env file
        run: |
          echo "Creating .env file with secrets..."
          echo "MINIO_ENDPOINT=${{ secrets.MINIO_ENDPOINT }}" > .env
          echo "MINIO_IMAGE_BUCKET=${{ secrets.MINIO_IMAGE_BUCKET }}" >> .env
          echo "MINIO_KEY=${{ secrets.MINIO_KEY }}" >> .env
          echo "MINIO_PORT=${{ secrets.MINIO_PORT }}" >> .env
          echo "MINIO_SECRET=${{ secrets.MINIO_SECRET }}" >> .env
          echo "MONGODB_URI=${{ secrets.MONGODB_URI }}" >> .env
          echo "JWT_ACCESS_SECRET=${{ secrets.JWT_ACCESS_SECRET }}" >> .env
          echo "JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}" >> .env
          echo "REDIS_HOST=redis-db" >> .env
          echo "REDIS_PORT=6379" >> .env

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: false
          tags: portfolio:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=docker,dest=/tmp/portfolio-image.tar

      - name: Load Docker image
        run: docker load -i /tmp/portfolio-image.tar

      - name: Scan Docker image for vulnerabilities
        uses: aquasecurity/trivy-action@0.30.0
        with:
          image-ref: 'portfolio:latest'
          format: 'table'
          exit-code: '1'
          severity: 'CRITICAL,HIGH'
          ignore-unfixed: true

      - name: Compress Docker image
        run: |
          echo "Compressing Docker image..."
          gzip /tmp/portfolio-image.tar
          mv /tmp/portfolio-image.tar.gz portfolio-image.tar.gz

      - name: Transfer Docker image to server
        run: |
          echo "Transferring Docker image to server..."
          scp -o StrictHostKeyChecking=no portfolio-image.tar.gz ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/home/arka/services/docker-images/portfolio-image.tar.gz
          scp -o StrictHostKeyChecking=no docker-compose.yml ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/home/arka/services/portfolio/docker-compose.yml
          scp -o StrictHostKeyChecking=no .env ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:/home/arka/services/portfolio/.env

      - name: Deploy to production
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << 'EOF'
            # Force using bash instead of fish
            bash -c '
            # Navigate to the services directory
            cd /home/arka/services/

            # Create portfolio directory if it does not exist
            mkdir -p portfolio
            cd portfolio

            # Stop the current container
            docker compose down || true

            # Load the new Docker image
            echo "Loading Docker image..."
            gunzip -c /home/arka/services/docker-images/portfolio-image.tar.gz | docker load

            # Start the container using the new image
            echo "Starting container..."
            docker compose up -d

            # Wait for container to be fully running
            echo "Waiting for container to be ready..."
            attempt=1
            max_attempts=30

            until [ $attempt -gt $max_attempts ] || docker container inspect portfolio --format="{{.State.Running}}" 2>/dev/null | grep -q "true"; do
              echo "Attempt $attempt/$max_attempts: Container not ready yet, waiting..."
              sleep 2
              attempt=$((attempt+1))
            done

            if [ $attempt -gt $max_attempts ]; then
              echo "Container failed to start properly within time limit!"
              docker compose logs
              exit 1
            fi

            # Further verification of application health
            echo "Verifying application health..."
            timeout=120
            start_time=$(date +%s)
            end_time=$((start_time + timeout))
            while [ $(date +%s) -lt $end_time ]; do
              if docker exec portfolio wget -q -O - --timeout=5 http://0.0.0.0:3000/api/ping > /dev/null 2>&1; then
                echo "Application is responding!"
                break
              fi
              echo "Waiting for application to respond..."
              sleep 10
            done

            if ! docker exec portfolio wget -q -O - --timeout=5 http://0.0.0.0:3000/api/ping > /dev/null 2>&1; then
              echo "Application failed to respond within timeout!"
              docker compose logs
              exit 1
            fi

            # Verify deployment
            echo "Deployment successful! Container is running and application is responding."
            docker ps | grep portfolio
            '
          EOF